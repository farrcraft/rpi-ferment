// Generated by CoffeeScript 1.6.2
(function() {
  var Controller, ExpressApp, IO, Sampler, Sockets, mongoose, statsd,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  statsd = require('node-statsd').StatsD;

  Sampler = require('./sampler.js');

  IO = require('./io.js');

  Sockets = require('./sockets.js');

  ExpressApp = require('./server.js');

  mongoose = require('mongoose');

  require('./orm/profile.js');

  Controller = (function() {
    Controller.prototype.config_ = {};

    Controller.prototype.state_ = {};

    Controller.prototype.io_ = null;

    Controller.prototype.debug_ = false;

    Controller.prototype.statsd_ = null;

    Controller.prototype.sampler_ = null;

    Controller.prototype.sockets_ = null;

    function Controller(config, debug, nolog) {
      this.processSample = __bind(this.processSample, this);
      this.getMode = __bind(this.getMode, this);
      this.setMode = __bind(this.setMode, this);
      this.getSv = __bind(this.getSv, this);
      this.setSv = __bind(this.setSv, this);
      this.setGpio = __bind(this.setGpio, this);
      this.getGpio = __bind(this.getGpio, this);
      this.config = __bind(this.config, this);
      this.debug = __bind(this.debug, this);
      this.run = __bind(this.run, this);
      var model, profileCallback, query, sensor, _i, _len, _ref,
        _this = this;

      this.debug_ = debug;
      this.config_ = config;
      if (!nolog) {
        if (this.debug_) {
          console.log('Creating statsd client...');
        }
        this.statsd_ = new statsd();
      }
      _ref = config.sensors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sensor = _ref[_i];
        this.state_[sensor.name] = {
          sv: 0,
          pv: 0,
          gpio: false,
          mode: 'manual',
          profile: null
        };
        if (sensor.type !== 'ambient') {
          this.state_[sensor.name].channel = sensor.gpio;
        }
      }
      model = mongoose.model('Profile');
      query = model.find();
      query.where('active', true);
      profileCallback = function(err, profiles) {
        var profile, _j, _len1, _results;

        if (err) {
          return;
        }
        _results = [];
        for (_j = 0, _len1 = profiles.length; _j < _len1; _j++) {
          profile = profiles[_j];
          _this.state_[profile.sensor].profile = profile;
          _this.state_[profile.sensor].mode = profile.control_mode;
          if (_this.debug_) {
            _results.push(console.log('Bound active profile [' + profile.name + '] to sensor [' + profile.sensor + ']'));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      query.exec(profileCallback);
      this.io_ = new IO(this.debug_, 'out');
      this.sockets_ = new Sockets(this);
      this.sockets_.run();
      this.sampler_ = new Sampler(this.config_.pollFrequency, this.config_.sensors, this.config_.sensorUnit, this);
      ExpressApp.set('controller', this);
      if (this.debug_) {
        console.log('Express API listening on port [' + this.config_.apiPort + ']');
      }
      ExpressApp.listen(this.config_.apiPort);
      return;
    }

    Controller.prototype.run = function() {
      return this.io_.setup(this.config_, this.sampler_.startSampling);
    };

    Controller.prototype.debug = function() {
      return this.debug_;
    };

    Controller.prototype.config = function() {
      return this.config_;
    };

    Controller.prototype.getGpio = function(sensor) {
      return this.state_[sensor].gpio;
    };

    Controller.prototype.setGpio = function(sensor, value) {
      var controlName, controlSignalCompletion,
        _this = this;

      this.state_[sensor].gpio = value;
      controlSignalCompletion = function() {
        var data;

        if (_this.debug_) {
          console.log('GPIO channel state updated');
          data = {
            sensor: sensor,
            state: value
          };
          _this.sockets_.io_.sockets.emit('setgpio', data);
        }
      };
      controlName = sensor + '_gpio_' + this.state_[sensor].channel;
      this.io_.signal(this.state_[sensor].channel, value, controlSignalCompletion);
      if (!this.statsd_) {
        return;
      }
      if (!value) {
        this.statsd_.decrement(controlName);
      } else {
        this.statsd_.increment(controlName);
      }
    };

    Controller.prototype.setSv = function(sensor, value) {
      var data;

      this.state_[sensor].sv = value;
      data = {
        sensor: sensor,
        value: value
      };
      this.sockets_.io_.sockets.emit('setsv', data);
    };

    Controller.prototype.getSv = function(sensor) {
      return this.state_[sensor].sv;
    };

    Controller.prototype.setMode = function(sensor, mode) {
      this.state_[sensor].mode = mode;
    };

    Controller.prototype.getMode = function(sensor) {
      return this.state_[sensor].mode;
    };

    Controller.prototype.processSample = function(sensor, value) {
      var activeStep, now, override, profileStart, statsdCallback, step, stepEnd, _i, _len, _ref,
        _this = this;

      this.state_[sensor].pv = value;
      if (this.debug_) {
        console.log('Processing sample value [' + value + '] for sensor [' + sensor + ']');
      }
      statsdCallback = function() {
        if (_this.debug_) {
          return console.log('statsd gauge data sent.');
        }
      };
      if (this.statsd_) {
        this.statsd_.gauge(sensor, value, 1, statsdCallback);
      }
      if (this.state_[sensor].gpio == null) {
        return;
      }
      override = false;
      if (this.state_[sensor].profile !== null) {
        activeStep = null;
        now = new Date();
        profileStart = this.state_[sensor].profile.start_time;
        _ref = this.state_[sensor].profile.steps;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          step = _ref[_i];
          stepEnd = new Date();
          stepEnd.setDate(profileStart.getDate() + step.duration);
          if (stepEnd < now) {
            activeStep = step;
            break;
          }
        }
        if (this.state_[sensor].profile.overrides.length > 0) {
          if (this.state_[sensor].overrides[this.state_[sensor].profile.overrides.length].action !== 'resume') {
            override = true;
          }
        }
        if (this.state_[sensor].profile.control_mode !== this.state_[sensor].mode) {
          if (this.debug_) {
            console.log('Switching sensor [' + sensor + '] control mode from [' + this.state_[sensor].mode + '] to [' + this.state_[sensor].profile.control_mode + ']');
          }
          this.state_[sensor].mode = this.state_[sensor].profile.control_mode;
        }
        if (activeStep !== null && this.state_[sensor].sv !== activeStep.temperature) {
          if (this.debug_) {
            console.log('Setting sensor [' + sensor + '] SV to Profile [' + this.state_[sensor].profile.name + '] Step [' + activeStep.name + '] temperature [' + activeStep.temperature + ']');
          }
          this.state_[sensor].sv = activeStep.temperature;
        }
      }
      if (this.state_[sensor].mode === 'auto' && override !== true) {
        if (value > this.state_[sensor].sv && this.state_[sensor].gpio) {
          if (this.debug_) {
            console.log('Disabling gpio channel: ' + this.state_[sensor].channel);
          }
          this.setGpio(sensor, false);
        } else if (value < this.state_[sensor].sv && !this.state_[sensor].gpio) {
          if (this.debug_) {
            console.log('Enabling gpio channel: ' + this.state_[sensor].channel);
          }
          this.setGpio(sensor, true);
        }
      }
    };

    return Controller;

  })();

  module.exports = Controller;

}).call(this);
