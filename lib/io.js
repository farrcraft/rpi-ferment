// Generated by CoffeeScript 1.6.2
(function() {
  var IO, gpio,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  gpio = require('rpi-gpio');

  IO = (function() {
    IO.prototype.controlChannels_ = [];

    IO.prototype.debug_ = false;

    function IO(debug) {
      this.setup = __bind(this.setup, this);
      this["export"] = __bind(this["export"], this);
      this.change = __bind(this.change, this);      this.debug_ = debug;
      return;
    }

    IO.prototype.change = function(channel, value) {
      if (this.debug_) {
        console.log('Channel ' + channel + ' value is now ' + value);
      }
      this.controlChannels_[channel].locked = false;
      this.controlChannels_[channel].enabled = value;
    };

    IO.prototype["export"] = function(channel) {
      if (this.debug_) {
        console.log('Channel ' + channel + ' exported');
        return this.controlChannels_[channel].initialized = true;
      }
    };

    IO.prototype.setup = function(config, next) {
      var sensor, _i, _len, _ref;

      gpio.on('export', this["export"]);
      gpio.setMode(gpio.MODE_BCM);
      _ref = config.sensors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sensor = _ref[_i];
        if (sensor.control !== "none") {
          if (this.debug_) {
            console.log('Enabling GPIO ' + sensor.gpio + ' for writing...');
          }
          gpio.setup(sensor.gpio, gpio.DIR_OUT, next);
          this.controlChannels_[sensor.gpio] = {
            enabled: false,
            locked: false,
            initialized: false
          };
        }
      }
      gpio.on('change', this.change);
    };

    IO.prototype.signalCallback = function(err) {
      if (err) {
        throw err;
      }
    };

    IO.prototype.signal = function(channel, state, next) {
      var channels;

      if (this.enabled(channel) !== state && !this.locked(channel) && this.initialized(channel)) {
        channels = this.controlChannels_;
        if (this.debug_) {
          console.log('Writing to GPIO channel ' + channel);
        }
        gpio.write(channel, state, next);
        this.controlChannels_[channel].locked = true;
      }
    };

    IO.prototype.enabled = function(channel) {
      return this.controlChannels_[channel].enabled;
    };

    IO.prototype.locked = function(channel) {
      return this.controlChannels_[channel].locked;
    };

    IO.prototype.initialized = function(channel) {
      return this.controlChannels_[channel].initialized;
    };

    return IO;

  })();

  module.exports = IO;

}).call(this);
