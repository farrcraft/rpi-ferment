// Generated by CoffeeScript 1.6.2
(function() {
  var IO, async, gpio,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  gpio = require('rpi-gpio');

  async = require('async');

  IO = (function() {
    IO.prototype.controlChannels_ = [];

    IO.prototype.debug_ = false;

    function IO(debug) {
      this.setup = __bind(this.setup, this);
      this["export"] = __bind(this["export"], this);
      this.change = __bind(this.change, this);      this.debug_ = debug;
      return;
    }

    IO.prototype.change = function(channel, value) {
      if (this.debug_) {
        console.log('Channel ' + channel + ' value is now ' + value);
      }
      this.controlChannels_[channel].locked = false;
      this.controlChannels_[channel].enabled = value;
    };

    IO.prototype["export"] = function(channel) {
      if (this.debug_) {
        console.log('Channel ' + channel + ' exported');
        return this.controlChannels_[channel].initialized = true;
      }
    };

    IO.prototype.setup = function(config) {
      var callback, checkStatus, sensor, waiting, _i, _len, _ref;

      gpio.on('export', this["export"]);
      gpio.setMode(gpio.MODE_BCM);
      _ref = config.sensors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sensor = _ref[_i];
        if (sensor.control !== "none") {
          if (this.debug_) {
            console.log('Enabling GPIO ' + sensor.gpio + ' for writing...');
          }
          gpio.setup(sensor.gpio, gpio.DIR_OUT);
          this.controlChannels_[sensor.gpio] = {
            enabled: false,
            locked: false,
            initialized: false
          };
        }
      }
      checkStatus = function() {
        return this.controlChannels_[sensor.gpio].initialized === false;
      };
      waiting = function(callback) {
        if (this.debug_) {
          return console.log('.');
        }
      };
      callback = function(err) {
        if (err) {
          console.log(err);
        }
        if (this.debug_) {
          return console.log('GPIO ' + sensor.gpio + ' enabled.');
        }
      };
      async.whilst(checkStatus, waiting, callback);
      gpio.on('change', this.change);
    };

    IO.prototype.signalCallback = function(err) {
      if (err) {
        throw err;
      }
    };

    IO.prototype.signal = function(channel, state) {
      var callback, checkStatus, waiting;

      if (this.enabled(channel) !== state && !this.locked(channel)) {
        checkStatus = function() {
          return this.controlChannels_[sensor.gpio].initialized === false;
        };
        waiting = function(callback) {
          if (this.debug_) {
            return console.log('.');
          }
        };
        callback = function(err) {
          if (err) {
            return console.log(err);
          } else {
            if (this.debug_) {
              console.log('Writing to GPIO channel ' + channel);
            }
            return gpio.write(channel, state, this.signalCallback);
          }
        };
        async.whilst(checkStatus, waiting, callback);
        this.controlChannels_[channel].locked = true;
      }
    };

    IO.prototype.enabled = function(channel) {
      return this.controlChannels_[channel].enabled;
    };

    IO.prototype.locked = function(channel) {
      return this.controlChannels_[channel].locked;
    };

    return IO;

  })();

  module.exports = IO;

}).call(this);
