// Generated by CoffeeScript 1.6.2
(function() {
  var IO, gpio,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  gpio = require('rpi-gpio');

  IO = (function() {
    IO.prototype.controlChannels_ = [];

    IO.prototype.debug_ = false;

    IO.prototype.direction_ = 'out';

    function IO(debug, direction) {
      this.state = __bind(this.state, this);
      this.setup = __bind(this.setup, this);
      this["export"] = __bind(this["export"], this);
      this.status = __bind(this.status, this);
      this.change = __bind(this.change, this);      this.debug_ = debug;
      this.direction_ = direction;
      return;
    }

    IO.prototype.change = function(channel, value) {
      if (this.debug_) {
        console.log('Channel ' + channel + ' value is now ' + value);
      }
      this.controlChannels_[channel].locked = false;
      this.controlChannels_[channel].enabled = value;
    };

    IO.prototype.status = function(channel, next) {
      if (this.direction_ !== 'in') {
        console.log('IO must be set to "in" to query status!');
        return;
      }
      gpio.read(channel, next);
    };

    IO.prototype["export"] = function(channel) {
      if (this.debug_) {
        console.log('Channel ' + channel + ' exported');
      }
      this.controlChannels_[channel].initialized = true;
    };

    IO.prototype.setup = function(config, next) {
      var direction, sensor, _i, _len, _ref;

      gpio.on('export', this["export"]);
      gpio.setMode(gpio.MODE_BCM);
      _ref = config.sensors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sensor = _ref[_i];
        if (sensor.gpio != null) {
          if (this.debug_) {
            console.log('Enabling GPIO ' + sensor.gpio + ' for writing...');
          }
          direction = gpio.DIR_OUT;
          if (this.direction_ === 'in') {
            direction = gpio.DIR_IN;
          }
          gpio.setup(sensor.gpio, direction, next);
          this.controlChannels_[sensor.gpio] = {
            direction: this.direction_,
            enabled: false,
            locked: false,
            initialized: false
          };
        }
      }
      gpio.on('change', this.change);
    };

    IO.prototype.state = function(channel, state) {
      var oldstate;

      oldstate = this.controlChannels_[channel].state;
      this.controlChannels_[channel].state = state;
      return oldstate;
    };

    IO.prototype.signal = function(channel, state, next) {
      var channels;

      if (this.enabled(channel) !== state && !this.locked(channel) && this.initialized(channel)) {
        channels = this.controlChannels_;
        if (this.debug_) {
          console.log('Writing to GPIO channel ' + channel);
        }
        gpio.write(channel, state, next);
        this.controlChannels_[channel].locked = true;
      }
    };

    IO.prototype.enabled = function(channel) {
      return this.controlChannels_[channel].enabled;
    };

    IO.prototype.locked = function(channel) {
      return this.controlChannels_[channel].locked;
    };

    IO.prototype.initialized = function(channel) {
      return this.controlChannels_[channel].initialized;
    };

    return IO;

  })();

  module.exports = IO;

}).call(this);
